diff --git a/firmware/cameralink_gateway/_Application.py b/firmware/cameralink_gateway/_Application.py
new file mode 100644
index 0000000..526baa4
--- /dev/null
+++ b/firmware/cameralink_gateway/_Application.py
@@ -0,0 +1,50 @@
+#!/usr/bin/env python3
+#-----------------------------------------------------------------------------
+# This file is part of the 'Camera link gateway'. It is subject to
+# the license terms in the LICENSE.txt file found in the top-level directory
+# of this distribution and at:
+#    https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
+# No part of the 'Camera link gateway', including this file, may be
+# copied, modified, propagated, or distributed except according to the terms
+# contained in the LICENSE.txt file.
+#-----------------------------------------------------------------------------
+
+import pyrogue as pr
+
+import surf.protocols.batcher as batcher
+
+class AppLane(pr.Device):
+    def __init__(   self,
+            name        = "AppLane",
+            description = "PCIe Application Lane Container",
+            **kwargs):
+        super().__init__(name=name, description=description, **kwargs)
+
+        #######################################
+        # SLAVE[TDEST=0] = XPM Trigger
+        # SLAVE[TDEST=1] = XPM Event Transition
+        # SLAVE[TDEST=2] = Camera Image
+        #######################################
+        self.add(batcher.AxiStreamBatcherEventBuilder(
+            name         = 'EventBuilder',
+            offset       = 0x00000,
+            numberSlaves = 2,
+            tickUnit     = '156.25MHz',
+            expand       = True,
+        ))
+
+class Application(pr.Device):
+    def __init__(   self,
+            name        = "Application",
+            description = "PCIe Lane Container",
+            numLanes    = 4, # number of PGP Lanes
+            **kwargs):
+        super().__init__(name=name, description=description, **kwargs)
+
+        for i in range(numLanes):
+
+            self.add(AppLane(
+                name   = ('AppLane[%i]' % i),
+                offset = (i*0x0008_0000),
+                expand = True,
+            ))
diff --git a/firmware/cameralink_gateway/_ClinkDevKcu1500.py b/firmware/cameralink_gateway/_ClinkDevKcu1500.py
new file mode 100644
index 0000000..a9bb090
--- /dev/null
+++ b/firmware/cameralink_gateway/_ClinkDevKcu1500.py
@@ -0,0 +1,49 @@
+#!/usr/bin/env python3
+#-----------------------------------------------------------------------------
+# This file is part of the 'Camera link gateway'. It is subject to
+# the license terms in the LICENSE.txt file found in the top-level directory
+# of this distribution and at:
+#    https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
+# No part of the 'Camera link gateway', including this file, may be
+# copied, modified, propagated, or distributed except according to the terms
+# contained in the LICENSE.txt file.
+#-----------------------------------------------------------------------------
+import pyrogue as pr
+
+import axipcie                                 as pcie
+import cameralink_gateway                      as clDev
+import lcls2_pgp_fw_lib.hardware.XilinxKcu1500 as xilinxKcu1500
+
+class ClinkDevKcu1500(pr.Device):
+    def __init__(self,
+                 numLanes = 4,
+                 pgp3     = False,
+                 enLclsI  = True,
+                 enLclsII = False,
+                 **kwargs):
+        super().__init__(**kwargs)
+
+        # Core Layer
+        self.add(pcie.AxiPcieCore(
+            offset      = 0x0000_0000,
+            numDmaLanes = numLanes,
+            expand      = False,
+        ))
+
+        # Application layer
+        self.add(clDev.Application(
+            offset   = 0x00C0_0000,
+            numLanes = numLanes,
+            expand   = True,
+        ))
+
+        # Hardware Layer
+        self.add(xilinxKcu1500.Kcu1500Hsio(
+            name     = 'Hsio',
+            offset    = 0x0080_0000,
+            numLanes  = numLanes,
+            pgp3      = pgp3,
+            enLclsI   = enLclsI,
+            enLclsII  = enLclsII,
+            expand    = True,
+        ))
diff --git a/firmware/cameralink_gateway/_ClinkDevRoot.py b/firmware/cameralink_gateway/_ClinkDevRoot.py
new file mode 100644
index 0000000..79c8b51
--- /dev/null
+++ b/firmware/cameralink_gateway/_ClinkDevRoot.py
@@ -0,0 +1,340 @@
+#!/usr/bin/env python3
+#-----------------------------------------------------------------------------
+# This file is part of the 'Camera link gateway'. It is subject to
+# the license terms in the LICENSE.txt file found in the top-level directory
+# of this distribution and at:
+#    https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
+# No part of the 'Camera link gateway', including this file, may be
+# copied, modified, propagated, or distributed except according to the terms
+# contained in the LICENSE.txt file.
+#-----------------------------------------------------------------------------
+import pyrogue as pr
+import rogue
+import click
+
+import cameralink_gateway as clDev
+import axipcie
+
+import lcls2_pgp_fw_lib.hardware.shared as shared
+
+import ClinkFeb               as feb
+import surf.protocols.batcher as batcher
+import surf.protocols.clink   as cl
+import l2si_core              as l2si
+
+rogue.Version.minVersion('5.1.0')
+# rogue.Version.exactVersion('5.1.0')
+
+class ClinkDevRoot(shared.Root):
+
+    def __init__(self,
+                 dataDebug      = False,
+                 dev            = '/dev/datadev_0',# path to PCIe device
+                 enLclsI        = True,
+                 enLclsII       = False,
+                 startupMode    = False, # False = LCLS-I timing mode, True = LCLS-II timing mode
+                 standAloneMode = False, # False = using fiber timing, True = locally generated timing
+                 pgp3           = False, # true = PGPv3, false = PGP2b
+                 pollEn         = True,  # Enable automatic polling registers
+                 initRead       = True,  # Read all registers at start of the system
+                 numLanes       = 4,     # Number of PGP lanes
+                 camType        = None,
+                 defaultFile    = None,
+                 enableDump     = False,
+                 clDevTarget    = clDev.ClinkDevKcu1500,
+                 **kwargs):
+
+        # Set the firmware Version lock = firmware/targets/shared_version.mk
+        self.FwVersionLock = 0x04090000
+
+        # Set number of lanes to min. requirement
+        if numLanes > len(camType):
+            laneSize = len(camType)
+        else:
+            laneSize = numLanes
+
+        # Set local variables
+        self.camType        = [camType[i] for i in range(laneSize)]
+        self.defaultFile    = defaultFile
+        self.dev            = dev
+        self.startupMode    = startupMode
+        self.standAloneMode = standAloneMode
+        self.enableDump     = enableDump
+
+        # Check for simulation
+        if dev == 'sim':
+            kwargs['timeout'] = 100000000 # 100 s
+        else:
+            kwargs['timeout'] = 5000000 # 5 s
+
+        # Pass custom value to parent via super function
+        super().__init__(
+            dev         = dev,
+            pgp3        = pgp3,
+            pollEn      = pollEn,
+            initRead    = initRead,
+            numLanes    = laneSize,
+            **kwargs)
+
+        # Unhide the RemoteVariableDump command
+        self.RemoteVariableDump.hidden = False
+
+        # Create memory interface
+        self.memMap = axipcie.createAxiPcieMemMap(dev, 'localhost', 8000)
+
+        # Instantiate the top level Device and pass it the memory map
+        self.add(clDevTarget(
+            name     = 'ClinkPcie',
+            memBase  = self.memMap,
+            numLanes = laneSize,
+            pgp3     = pgp3,
+            enLclsI  = enLclsI,
+            enLclsII = enLclsII,
+            expand   = True,
+        ))
+
+        # CLink SRP, CLink serial
+        destList = [0, 2]
+
+        # Create DMA streams
+        self.dmaStreams = axipcie.createAxiPcieDmaStreams(
+            dev, {lane:{dest for dest in destList} for lane in range(laneSize)}, 'localhost', 8000)
+
+        # Check if not doing simulation
+        if (dev!='sim'):
+
+            # Create arrays to be filled
+            self._srp = [None for lane in range(laneSize)]
+
+            # Create the stream interface
+            for lane in range(laneSize):
+
+                # SRP
+                self._srp[lane] = rogue.protocols.srp.SrpV3()
+                pr.streamConnectBiDir(self.dmaStreams[lane][0],self._srp[lane])
+
+                # CameraLink Feb Board
+                self.add(feb.ClinkFeb(
+                    name       = (f'ClinkFeb[{lane}]'),
+                    memBase    = self._srp[lane],
+                    serial     = self.dmaStreams[lane][2],
+                    camType    = self.camType[lane],
+                    version3   = pgp3,
+                    enableDeps = [self.ClinkPcie.Hsio.PgpMon[lane].RxRemLinkReady], # Only allow access if the PGP link is established
+                    expand     = True,
+                ))
+
+        # Else doing Rogue VCS simulation
+        else:
+            self.roguePgp = shared.RogueStreams(numLanes=laneSize, pgp3=pgp3)
+
+            # Create arrays to be filled
+            self._frameGen = [None for lane in range(laneSize)]
+
+            # Create the stream interface
+            for lane in range(laneSize):
+
+                # Create the frame generator
+                self._frameGen[lane] = MyCustomMaster()
+
+                # Connect the frame generator
+                print(self.roguePgp.pgpStreams)
+                self._frameGen[lane] >> self.roguePgp.pgpStreams[lane][1]
+
+                # Create a command to execute the frame generator
+                self.add(pr.BaseCommand(
+                    name         = f'GenFrame[{lane}]',
+                    function     = lambda cmd, lane=lane: self._frameGen[lane].myFrameGen(),
+                ))
+
+                # Create a command to execute the frame generator. Accepts user data argument
+                self.add(pr.BaseCommand(
+                    name         = f'GenUserFrame[{lane}]',
+                    function     = lambda cmd, lane=lane: self._frameGen[lane].myFrameGen,
+                ))
+
+        # Create arrays to be filled
+        self._dbg = [None for lane in range(laneSize)]
+        self.unbatchers = [rogue.protocols.batcher.SplitterV1() for lane in range(laneSize)]
+
+        # Create the stream interface
+        for lane in range(laneSize):
+            # Debug slave
+            if dataDebug:
+                # Connect the streams
+                self.dmaStreams[lane][1] >> self.unbatchers[lane] >> self._dbg[lane]
+
+        self.add(pr.LocalVariable(
+            name        = 'RunState',
+            description = 'Run state status, which is controlled by the StopRun() and StartRun() commands',
+            mode        = 'RO',
+            value       = False,
+        ))
+
+        @self.command(description  = 'Stops the triggers and blows off data in the pipeline')
+        def StopRun():
+            print ('ClinkDev.StopRun() executed')
+
+            # Get devices
+            eventBuilder = self.find(typ=batcher.AxiStreamBatcherEventBuilder)
+            trigger      = self.find(typ=l2si.TriggerEventBuffer)
+
+            # Turn off the triggering
+            for devPtr in trigger:
+                devPtr.MasterEnable.set(False)
+
+            # Flush the downstream data/trigger pipelines
+            for devPtr in eventBuilder:
+                devPtr.Blowoff.set(True)
+
+            # Update the run state status variable
+            self.RunState.set(False)
+
+        @self.command(description  = 'starts the triggers and allow steams to flow to DMA engine')
+        def StartRun():
+            print ('ClinkDev.StartRun() executed')
+
+            # Get devices
+            eventBuilder = self.find(typ=batcher.AxiStreamBatcherEventBuilder)
+            trigger      = self.find(typ=l2si.TriggerEventBuffer)
+
+            # Reset all counters
+            self.CountReset()
+
+            # Arm for data/trigger stream
+            for devPtr in eventBuilder:
+                devPtr.Blowoff.set(False)
+                devPtr.SoftRst()
+
+            # Turn on the triggering
+            for devPtr in trigger:
+                devPtr.MasterEnable.set(True)
+
+            # Update the run state status variable
+            self.RunState.set(True)
+
+    def start(self, **kwargs):
+        super().start(**kwargs)
+
+        # Hide all the "enable" variables
+        for enableList in self.find(typ=pr.EnableVariable):
+            # Hide by default
+            enableList.hidden = True
+
+        # Check if simulation
+        if (self.dev=='sim'):
+            pass
+
+        else:
+            self.ReadAll()
+            self.ReadAll()
+            if (self.enableDump):
+                # Dump the state of the hardware before configuration
+                print(f'Dumping pre-configurations...')
+                self.SaveConfig('dump/config-dump-pre-config.yml')
+                self.SaveState('dump/state-dump-pre-config.yml')
+                # Dump the address map
+                self.saveAddressMap( "dump/addressMapDump.dump" )
+                self.saveAddressMap( "dump/addressMapDump.h", headerEn=True )
+
+            # Check for PCIe FW version
+            fwVersion = self.ClinkPcie.AxiPcieCore.AxiVersion.FpgaVersion.get()
+            if (fwVersion != self.FwVersionLock):
+                errMsg = f"""
+                    PCIe.AxiVersion.FpgaVersion = {fwVersion:#04x} != {self.FwVersionLock:#04x}
+                    Please update PCIe firmware using software/scripts/updatePcieFpga.py
+                    """
+                click.secho(errMsg, bg='red')
+                raise ValueError(errMsg)
+
+            # Check for FEB FW version
+            for lane in range(self.numLanes):
+                # Unhide the because dependent on PGP link status
+                self.ClinkFeb[lane].enable.hidden = False
+                # Check for PGP link up
+                if (self.ClinkPcie.Hsio.PgpMon[lane].RxRemLinkReady.get() != 0):
+                    # Check for FW version
+                    fwVersion = self.ClinkFeb[lane].AxiVersion.FpgaVersion.get()
+                    if (fwVersion != self.FwVersionLock):
+                        errMsg = f"""
+                            Fpga[lane={lane}].AxiVersion.FpgaVersion = {fwVersion:#04x} != {self.FwVersionLock:#04x}
+                            Please update Fpga[{lane}] at Lane={lane} firmware using software/scripts/updateFeb.py
+                            """
+                        click.secho(errMsg, bg='red')
+                        raise ValueError(errMsg)
+                else:
+                    self.ClinkPcie.Application.AppLane[lane]._expand = False
+
+            # Startup procedures for OPAL1000
+            uartDev = self.find(typ=cl.UartOpal1000)
+            for dev in uartDev:
+                pass
+
+            # Startup procedures for Piranha4
+            uartDev = self.find(typ=cl.UartPiranha4)
+            for dev in uartDev:
+                dev.SendEscape()
+                dev.SPF.setDisp('0')
+                dev.GCP()
+
+            # Startup procedures for Up900cl12b
+            uartDev = self.find(typ=cl.UartUp900cl12b)
+            for dev in uartDev:
+                clCh = self.find(typ=cl.ClinkChannel)
+                for clChDev in clCh:
+                    clChDev.SerThrottle.set(30000)
+                dev.AM()
+                dev.SM.set('f')
+                dev.RP()
+
+        # Load the configurations
+        if self.defaultFile is not None:
+
+            # Useful pointer
+            timingRx = self.ClinkPcie.Hsio.TimingRx
+
+            # Start up the timing system = LCLS-II mode
+            if self.startupMode:
+
+                # Set the default to  LCLS-II mode
+                defaultFile = ["config/defaults_LCLS-II.yml",self.defaultFile]
+
+                # Startup in LCLS-II mode
+                if self.standAloneMode:
+                    timingRx.ConfigureXpmMini()
+                else:
+                    timingRx.ConfigLclsTimingV2()
+
+            # Else LCLS-I mode
+            else:
+
+                # Set the default to  LCLS-I mode
+                defaultFile = ["config/defaults_LCLS-I.yml",self.defaultFile]
+
+                # Startup in LCLS-I mode
+                if self.standAloneMode:
+                    timingRx.ConfigureTpgMiniStream()
+                else:
+                    timingRx.ConfigLclsTimingV1()
+
+            # Read all the variables
+            self.ReadAll()
+            self.ReadAll()
+
+            # Load the YAML configurations
+            print(f'Loading {defaultFile} Configuration File...')
+            self.LoadConfig(defaultFile)
+
+            if (self.enableDump):
+                # Dump the state of the hardware before configuration
+                self.ReadAll()
+                self.ReadAll()
+                print(f'Dumping post-configurations...')
+                self.SaveConfig('dump/config-dump-post-config.yml')
+                self.SaveState('dump/state-dump-post-config.yml')
+
+    # Function calls after loading YAML configuration
+    def initialize(self):
+        super().initialize()
+        self.StopRun()
+        self.CountReset()
diff --git a/firmware/cameralink_gateway/_ClinkDevSlacPgpCardG4.py b/firmware/cameralink_gateway/_ClinkDevSlacPgpCardG4.py
new file mode 100644
index 0000000..87fc8f6
--- /dev/null
+++ b/firmware/cameralink_gateway/_ClinkDevSlacPgpCardG4.py
@@ -0,0 +1,49 @@
+#!/usr/bin/env python3
+#-----------------------------------------------------------------------------
+# This file is part of the 'Camera link gateway'. It is subject to
+# the license terms in the LICENSE.txt file found in the top-level directory
+# of this distribution and at:
+#    https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
+# No part of the 'Camera link gateway', including this file, may be
+# copied, modified, propagated, or distributed except according to the terms
+# contained in the LICENSE.txt file.
+#-----------------------------------------------------------------------------
+import pyrogue as pr
+
+import axipcie                                 as pcie
+import cameralink_gateway                      as clDev
+import lcls2_pgp_fw_lib.hardware.SlacPgpCardG4 as SlacPgpCardG4
+
+class ClinkDevSlacPgpCardG4(pr.Device):
+    def __init__(self,
+                 numLanes = 8,
+                 pgp3     = False,
+                 enLclsI  = True,
+                 enLclsII = False,
+                 **kwargs):
+        super().__init__(**kwargs)
+
+        # Core Layer
+        self.add(pcie.AxiPcieCore(
+            offset      = 0x0000_0000,
+            numDmaLanes = numLanes,
+            expand      = False,
+        ))
+
+        # Application layer
+        self.add(clDev.Application(
+            offset   = 0x00C0_0000,
+            numLanes = numLanes,
+            expand   = True,
+        ))
+
+        # Hardware Layer
+        self.add(SlacPgpCardG4.SlacPgpCardG4Hsio(
+            name     = 'Hsio',
+            offset    = 0x0080_0000,
+            numLanes  = numLanes,
+            pgp3      = pgp3,
+            enLclsI   = enLclsI,
+            enLclsII  = enLclsII,
+            expand    = True,
+        ))
diff --git a/firmware/cameralink_gateway/__init__.py b/firmware/cameralink_gateway/__init__.py
new file mode 100644
index 0000000..6032fa4
--- /dev/null
+++ b/firmware/cameralink_gateway/__init__.py
@@ -0,0 +1,17 @@
+#!/usr/bin/env python
+
+# this sys.path.append is a hack to allow a rogue device to import its
+# own version of device-specific submodules (surf/axi-pcie-core etc.) that
+# have been placed as subdirectories here by setup.py.  ryan herbst
+# thinks of these packages as a device-specific "board support package".
+# this allows one to put multiple devices in the same conda env.
+# a cleaner approach would be to use relative imports everywhere, but
+# that would be a lot of work for the tid-air people - cpo.
+import sys
+import os
+sys.path.append(os.path.dirname(os.path.realpath(__file__)))
+
+from cameralink_gateway._Application                  import *
+from cameralink_gateway._ClinkDevKcu1500              import *
+from cameralink_gateway._ClinkDevSlacPgpCardG4        import *
+from cameralink_gateway._ClinkDevRoot                 import *
diff --git a/firmware/python/cameralink_gateway/_Application.py b/firmware/python/cameralink_gateway/_Application.py
deleted file mode 100644
index 526baa4..0000000
--- a/firmware/python/cameralink_gateway/_Application.py
+++ /dev/null
@@ -1,50 +0,0 @@
-#!/usr/bin/env python3
-#-----------------------------------------------------------------------------
-# This file is part of the 'Camera link gateway'. It is subject to
-# the license terms in the LICENSE.txt file found in the top-level directory
-# of this distribution and at:
-#    https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
-# No part of the 'Camera link gateway', including this file, may be
-# copied, modified, propagated, or distributed except according to the terms
-# contained in the LICENSE.txt file.
-#-----------------------------------------------------------------------------
-
-import pyrogue as pr
-
-import surf.protocols.batcher as batcher
-
-class AppLane(pr.Device):
-    def __init__(   self,
-            name        = "AppLane",
-            description = "PCIe Application Lane Container",
-            **kwargs):
-        super().__init__(name=name, description=description, **kwargs)
-
-        #######################################
-        # SLAVE[TDEST=0] = XPM Trigger
-        # SLAVE[TDEST=1] = XPM Event Transition
-        # SLAVE[TDEST=2] = Camera Image
-        #######################################
-        self.add(batcher.AxiStreamBatcherEventBuilder(
-            name         = 'EventBuilder',
-            offset       = 0x00000,
-            numberSlaves = 2,
-            tickUnit     = '156.25MHz',
-            expand       = True,
-        ))
-
-class Application(pr.Device):
-    def __init__(   self,
-            name        = "Application",
-            description = "PCIe Lane Container",
-            numLanes    = 4, # number of PGP Lanes
-            **kwargs):
-        super().__init__(name=name, description=description, **kwargs)
-
-        for i in range(numLanes):
-
-            self.add(AppLane(
-                name   = ('AppLane[%i]' % i),
-                offset = (i*0x0008_0000),
-                expand = True,
-            ))
diff --git a/firmware/python/cameralink_gateway/_ClinkDevKcu1500.py b/firmware/python/cameralink_gateway/_ClinkDevKcu1500.py
deleted file mode 100644
index a9bb090..0000000
--- a/firmware/python/cameralink_gateway/_ClinkDevKcu1500.py
+++ /dev/null
@@ -1,49 +0,0 @@
-#!/usr/bin/env python3
-#-----------------------------------------------------------------------------
-# This file is part of the 'Camera link gateway'. It is subject to
-# the license terms in the LICENSE.txt file found in the top-level directory
-# of this distribution and at:
-#    https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
-# No part of the 'Camera link gateway', including this file, may be
-# copied, modified, propagated, or distributed except according to the terms
-# contained in the LICENSE.txt file.
-#-----------------------------------------------------------------------------
-import pyrogue as pr
-
-import axipcie                                 as pcie
-import cameralink_gateway                      as clDev
-import lcls2_pgp_fw_lib.hardware.XilinxKcu1500 as xilinxKcu1500
-
-class ClinkDevKcu1500(pr.Device):
-    def __init__(self,
-                 numLanes = 4,
-                 pgp3     = False,
-                 enLclsI  = True,
-                 enLclsII = False,
-                 **kwargs):
-        super().__init__(**kwargs)
-
-        # Core Layer
-        self.add(pcie.AxiPcieCore(
-            offset      = 0x0000_0000,
-            numDmaLanes = numLanes,
-            expand      = False,
-        ))
-
-        # Application layer
-        self.add(clDev.Application(
-            offset   = 0x00C0_0000,
-            numLanes = numLanes,
-            expand   = True,
-        ))
-
-        # Hardware Layer
-        self.add(xilinxKcu1500.Kcu1500Hsio(
-            name     = 'Hsio',
-            offset    = 0x0080_0000,
-            numLanes  = numLanes,
-            pgp3      = pgp3,
-            enLclsI   = enLclsI,
-            enLclsII  = enLclsII,
-            expand    = True,
-        ))
diff --git a/firmware/python/cameralink_gateway/_ClinkDevRoot.py b/firmware/python/cameralink_gateway/_ClinkDevRoot.py
deleted file mode 100644
index 79c8b51..0000000
--- a/firmware/python/cameralink_gateway/_ClinkDevRoot.py
+++ /dev/null
@@ -1,340 +0,0 @@
-#!/usr/bin/env python3
-#-----------------------------------------------------------------------------
-# This file is part of the 'Camera link gateway'. It is subject to
-# the license terms in the LICENSE.txt file found in the top-level directory
-# of this distribution and at:
-#    https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
-# No part of the 'Camera link gateway', including this file, may be
-# copied, modified, propagated, or distributed except according to the terms
-# contained in the LICENSE.txt file.
-#-----------------------------------------------------------------------------
-import pyrogue as pr
-import rogue
-import click
-
-import cameralink_gateway as clDev
-import axipcie
-
-import lcls2_pgp_fw_lib.hardware.shared as shared
-
-import ClinkFeb               as feb
-import surf.protocols.batcher as batcher
-import surf.protocols.clink   as cl
-import l2si_core              as l2si
-
-rogue.Version.minVersion('5.1.0')
-# rogue.Version.exactVersion('5.1.0')
-
-class ClinkDevRoot(shared.Root):
-
-    def __init__(self,
-                 dataDebug      = False,
-                 dev            = '/dev/datadev_0',# path to PCIe device
-                 enLclsI        = True,
-                 enLclsII       = False,
-                 startupMode    = False, # False = LCLS-I timing mode, True = LCLS-II timing mode
-                 standAloneMode = False, # False = using fiber timing, True = locally generated timing
-                 pgp3           = False, # true = PGPv3, false = PGP2b
-                 pollEn         = True,  # Enable automatic polling registers
-                 initRead       = True,  # Read all registers at start of the system
-                 numLanes       = 4,     # Number of PGP lanes
-                 camType        = None,
-                 defaultFile    = None,
-                 enableDump     = False,
-                 clDevTarget    = clDev.ClinkDevKcu1500,
-                 **kwargs):
-
-        # Set the firmware Version lock = firmware/targets/shared_version.mk
-        self.FwVersionLock = 0x04090000
-
-        # Set number of lanes to min. requirement
-        if numLanes > len(camType):
-            laneSize = len(camType)
-        else:
-            laneSize = numLanes
-
-        # Set local variables
-        self.camType        = [camType[i] for i in range(laneSize)]
-        self.defaultFile    = defaultFile
-        self.dev            = dev
-        self.startupMode    = startupMode
-        self.standAloneMode = standAloneMode
-        self.enableDump     = enableDump
-
-        # Check for simulation
-        if dev == 'sim':
-            kwargs['timeout'] = 100000000 # 100 s
-        else:
-            kwargs['timeout'] = 5000000 # 5 s
-
-        # Pass custom value to parent via super function
-        super().__init__(
-            dev         = dev,
-            pgp3        = pgp3,
-            pollEn      = pollEn,
-            initRead    = initRead,
-            numLanes    = laneSize,
-            **kwargs)
-
-        # Unhide the RemoteVariableDump command
-        self.RemoteVariableDump.hidden = False
-
-        # Create memory interface
-        self.memMap = axipcie.createAxiPcieMemMap(dev, 'localhost', 8000)
-
-        # Instantiate the top level Device and pass it the memory map
-        self.add(clDevTarget(
-            name     = 'ClinkPcie',
-            memBase  = self.memMap,
-            numLanes = laneSize,
-            pgp3     = pgp3,
-            enLclsI  = enLclsI,
-            enLclsII = enLclsII,
-            expand   = True,
-        ))
-
-        # CLink SRP, CLink serial
-        destList = [0, 2]
-
-        # Create DMA streams
-        self.dmaStreams = axipcie.createAxiPcieDmaStreams(
-            dev, {lane:{dest for dest in destList} for lane in range(laneSize)}, 'localhost', 8000)
-
-        # Check if not doing simulation
-        if (dev!='sim'):
-
-            # Create arrays to be filled
-            self._srp = [None for lane in range(laneSize)]
-
-            # Create the stream interface
-            for lane in range(laneSize):
-
-                # SRP
-                self._srp[lane] = rogue.protocols.srp.SrpV3()
-                pr.streamConnectBiDir(self.dmaStreams[lane][0],self._srp[lane])
-
-                # CameraLink Feb Board
-                self.add(feb.ClinkFeb(
-                    name       = (f'ClinkFeb[{lane}]'),
-                    memBase    = self._srp[lane],
-                    serial     = self.dmaStreams[lane][2],
-                    camType    = self.camType[lane],
-                    version3   = pgp3,
-                    enableDeps = [self.ClinkPcie.Hsio.PgpMon[lane].RxRemLinkReady], # Only allow access if the PGP link is established
-                    expand     = True,
-                ))
-
-        # Else doing Rogue VCS simulation
-        else:
-            self.roguePgp = shared.RogueStreams(numLanes=laneSize, pgp3=pgp3)
-
-            # Create arrays to be filled
-            self._frameGen = [None for lane in range(laneSize)]
-
-            # Create the stream interface
-            for lane in range(laneSize):
-
-                # Create the frame generator
-                self._frameGen[lane] = MyCustomMaster()
-
-                # Connect the frame generator
-                print(self.roguePgp.pgpStreams)
-                self._frameGen[lane] >> self.roguePgp.pgpStreams[lane][1]
-
-                # Create a command to execute the frame generator
-                self.add(pr.BaseCommand(
-                    name         = f'GenFrame[{lane}]',
-                    function     = lambda cmd, lane=lane: self._frameGen[lane].myFrameGen(),
-                ))
-
-                # Create a command to execute the frame generator. Accepts user data argument
-                self.add(pr.BaseCommand(
-                    name         = f'GenUserFrame[{lane}]',
-                    function     = lambda cmd, lane=lane: self._frameGen[lane].myFrameGen,
-                ))
-
-        # Create arrays to be filled
-        self._dbg = [None for lane in range(laneSize)]
-        self.unbatchers = [rogue.protocols.batcher.SplitterV1() for lane in range(laneSize)]
-
-        # Create the stream interface
-        for lane in range(laneSize):
-            # Debug slave
-            if dataDebug:
-                # Connect the streams
-                self.dmaStreams[lane][1] >> self.unbatchers[lane] >> self._dbg[lane]
-
-        self.add(pr.LocalVariable(
-            name        = 'RunState',
-            description = 'Run state status, which is controlled by the StopRun() and StartRun() commands',
-            mode        = 'RO',
-            value       = False,
-        ))
-
-        @self.command(description  = 'Stops the triggers and blows off data in the pipeline')
-        def StopRun():
-            print ('ClinkDev.StopRun() executed')
-
-            # Get devices
-            eventBuilder = self.find(typ=batcher.AxiStreamBatcherEventBuilder)
-            trigger      = self.find(typ=l2si.TriggerEventBuffer)
-
-            # Turn off the triggering
-            for devPtr in trigger:
-                devPtr.MasterEnable.set(False)
-
-            # Flush the downstream data/trigger pipelines
-            for devPtr in eventBuilder:
-                devPtr.Blowoff.set(True)
-
-            # Update the run state status variable
-            self.RunState.set(False)
-
-        @self.command(description  = 'starts the triggers and allow steams to flow to DMA engine')
-        def StartRun():
-            print ('ClinkDev.StartRun() executed')
-
-            # Get devices
-            eventBuilder = self.find(typ=batcher.AxiStreamBatcherEventBuilder)
-            trigger      = self.find(typ=l2si.TriggerEventBuffer)
-
-            # Reset all counters
-            self.CountReset()
-
-            # Arm for data/trigger stream
-            for devPtr in eventBuilder:
-                devPtr.Blowoff.set(False)
-                devPtr.SoftRst()
-
-            # Turn on the triggering
-            for devPtr in trigger:
-                devPtr.MasterEnable.set(True)
-
-            # Update the run state status variable
-            self.RunState.set(True)
-
-    def start(self, **kwargs):
-        super().start(**kwargs)
-
-        # Hide all the "enable" variables
-        for enableList in self.find(typ=pr.EnableVariable):
-            # Hide by default
-            enableList.hidden = True
-
-        # Check if simulation
-        if (self.dev=='sim'):
-            pass
-
-        else:
-            self.ReadAll()
-            self.ReadAll()
-            if (self.enableDump):
-                # Dump the state of the hardware before configuration
-                print(f'Dumping pre-configurations...')
-                self.SaveConfig('dump/config-dump-pre-config.yml')
-                self.SaveState('dump/state-dump-pre-config.yml')
-                # Dump the address map
-                self.saveAddressMap( "dump/addressMapDump.dump" )
-                self.saveAddressMap( "dump/addressMapDump.h", headerEn=True )
-
-            # Check for PCIe FW version
-            fwVersion = self.ClinkPcie.AxiPcieCore.AxiVersion.FpgaVersion.get()
-            if (fwVersion != self.FwVersionLock):
-                errMsg = f"""
-                    PCIe.AxiVersion.FpgaVersion = {fwVersion:#04x} != {self.FwVersionLock:#04x}
-                    Please update PCIe firmware using software/scripts/updatePcieFpga.py
-                    """
-                click.secho(errMsg, bg='red')
-                raise ValueError(errMsg)
-
-            # Check for FEB FW version
-            for lane in range(self.numLanes):
-                # Unhide the because dependent on PGP link status
-                self.ClinkFeb[lane].enable.hidden = False
-                # Check for PGP link up
-                if (self.ClinkPcie.Hsio.PgpMon[lane].RxRemLinkReady.get() != 0):
-                    # Check for FW version
-                    fwVersion = self.ClinkFeb[lane].AxiVersion.FpgaVersion.get()
-                    if (fwVersion != self.FwVersionLock):
-                        errMsg = f"""
-                            Fpga[lane={lane}].AxiVersion.FpgaVersion = {fwVersion:#04x} != {self.FwVersionLock:#04x}
-                            Please update Fpga[{lane}] at Lane={lane} firmware using software/scripts/updateFeb.py
-                            """
-                        click.secho(errMsg, bg='red')
-                        raise ValueError(errMsg)
-                else:
-                    self.ClinkPcie.Application.AppLane[lane]._expand = False
-
-            # Startup procedures for OPAL1000
-            uartDev = self.find(typ=cl.UartOpal1000)
-            for dev in uartDev:
-                pass
-
-            # Startup procedures for Piranha4
-            uartDev = self.find(typ=cl.UartPiranha4)
-            for dev in uartDev:
-                dev.SendEscape()
-                dev.SPF.setDisp('0')
-                dev.GCP()
-
-            # Startup procedures for Up900cl12b
-            uartDev = self.find(typ=cl.UartUp900cl12b)
-            for dev in uartDev:
-                clCh = self.find(typ=cl.ClinkChannel)
-                for clChDev in clCh:
-                    clChDev.SerThrottle.set(30000)
-                dev.AM()
-                dev.SM.set('f')
-                dev.RP()
-
-        # Load the configurations
-        if self.defaultFile is not None:
-
-            # Useful pointer
-            timingRx = self.ClinkPcie.Hsio.TimingRx
-
-            # Start up the timing system = LCLS-II mode
-            if self.startupMode:
-
-                # Set the default to  LCLS-II mode
-                defaultFile = ["config/defaults_LCLS-II.yml",self.defaultFile]
-
-                # Startup in LCLS-II mode
-                if self.standAloneMode:
-                    timingRx.ConfigureXpmMini()
-                else:
-                    timingRx.ConfigLclsTimingV2()
-
-            # Else LCLS-I mode
-            else:
-
-                # Set the default to  LCLS-I mode
-                defaultFile = ["config/defaults_LCLS-I.yml",self.defaultFile]
-
-                # Startup in LCLS-I mode
-                if self.standAloneMode:
-                    timingRx.ConfigureTpgMiniStream()
-                else:
-                    timingRx.ConfigLclsTimingV1()
-
-            # Read all the variables
-            self.ReadAll()
-            self.ReadAll()
-
-            # Load the YAML configurations
-            print(f'Loading {defaultFile} Configuration File...')
-            self.LoadConfig(defaultFile)
-
-            if (self.enableDump):
-                # Dump the state of the hardware before configuration
-                self.ReadAll()
-                self.ReadAll()
-                print(f'Dumping post-configurations...')
-                self.SaveConfig('dump/config-dump-post-config.yml')
-                self.SaveState('dump/state-dump-post-config.yml')
-
-    # Function calls after loading YAML configuration
-    def initialize(self):
-        super().initialize()
-        self.StopRun()
-        self.CountReset()
diff --git a/firmware/python/cameralink_gateway/_ClinkDevSlacPgpCardG4.py b/firmware/python/cameralink_gateway/_ClinkDevSlacPgpCardG4.py
deleted file mode 100644
index 87fc8f6..0000000
--- a/firmware/python/cameralink_gateway/_ClinkDevSlacPgpCardG4.py
+++ /dev/null
@@ -1,49 +0,0 @@
-#!/usr/bin/env python3
-#-----------------------------------------------------------------------------
-# This file is part of the 'Camera link gateway'. It is subject to
-# the license terms in the LICENSE.txt file found in the top-level directory
-# of this distribution and at:
-#    https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
-# No part of the 'Camera link gateway', including this file, may be
-# copied, modified, propagated, or distributed except according to the terms
-# contained in the LICENSE.txt file.
-#-----------------------------------------------------------------------------
-import pyrogue as pr
-
-import axipcie                                 as pcie
-import cameralink_gateway                      as clDev
-import lcls2_pgp_fw_lib.hardware.SlacPgpCardG4 as SlacPgpCardG4
-
-class ClinkDevSlacPgpCardG4(pr.Device):
-    def __init__(self,
-                 numLanes = 8,
-                 pgp3     = False,
-                 enLclsI  = True,
-                 enLclsII = False,
-                 **kwargs):
-        super().__init__(**kwargs)
-
-        # Core Layer
-        self.add(pcie.AxiPcieCore(
-            offset      = 0x0000_0000,
-            numDmaLanes = numLanes,
-            expand      = False,
-        ))
-
-        # Application layer
-        self.add(clDev.Application(
-            offset   = 0x00C0_0000,
-            numLanes = numLanes,
-            expand   = True,
-        ))
-
-        # Hardware Layer
-        self.add(SlacPgpCardG4.SlacPgpCardG4Hsio(
-            name     = 'Hsio',
-            offset    = 0x0080_0000,
-            numLanes  = numLanes,
-            pgp3      = pgp3,
-            enLclsI   = enLclsI,
-            enLclsII  = enLclsII,
-            expand    = True,
-        ))
diff --git a/firmware/python/cameralink_gateway/__init__.py b/firmware/python/cameralink_gateway/__init__.py
deleted file mode 100644
index 6032fa4..0000000
--- a/firmware/python/cameralink_gateway/__init__.py
+++ /dev/null
@@ -1,17 +0,0 @@
-#!/usr/bin/env python
-
-# this sys.path.append is a hack to allow a rogue device to import its
-# own version of device-specific submodules (surf/axi-pcie-core etc.) that
-# have been placed as subdirectories here by setup.py.  ryan herbst
-# thinks of these packages as a device-specific "board support package".
-# this allows one to put multiple devices in the same conda env.
-# a cleaner approach would be to use relative imports everywhere, but
-# that would be a lot of work for the tid-air people - cpo.
-import sys
-import os
-sys.path.append(os.path.dirname(os.path.realpath(__file__)))
-
-from cameralink_gateway._Application                  import *
-from cameralink_gateway._ClinkDevKcu1500              import *
-from cameralink_gateway._ClinkDevSlacPgpCardG4        import *
-from cameralink_gateway._ClinkDevRoot                 import *
diff --git a/firmware/python/setup.py b/firmware/python/setup.py
deleted file mode 100644
index 9ca94c3..0000000
--- a/firmware/python/setup.py
+++ /dev/null
@@ -1,24 +0,0 @@
-from setuptools import setup, find_packages
-
-# use softlinks to make the various "board-support-package" submodules
-# look like subpackages.  Then __init__.py will modify
-# sys.path so that the correct "local" versions of surf etc. are
-# picked up.  A better approach would be using relative imports
-# in the submodules, but that's more work.  -cpo
-
-subpackages = ['surf/python/surf','axi-pcie-core/python/axipcie','lcls-timing-core/python/LclsTimingCore','lcls2-pgp-fw-lib/python/lcls2_pgp_fw_lib','clink-gateway-fw-lib/python/ClinkFeb','l2si-core/python/l2si_core']
-
-import os
-print(os.path.dirname(os.path.realpath(__file__)))
-
-for pkgpath in subpackages:
-    pkgname = pkgpath.split('/')[-1]
-    linkname = os.path.join('cameralink_gateway',pkgname)
-    if os.path.islink(linkname): os.remove(linkname)
-    os.symlink(os.path.join('../../../firmware/submodules',pkgpath),linkname)
-
-setup(
-    name = 'cameralink_gateway',
-    description = 'LCLS II cameralink package',
-    packages = find_packages(),
-)
diff --git a/firmware/setup.py b/firmware/setup.py
new file mode 100644
index 0000000..0d6f919
--- /dev/null
+++ b/firmware/setup.py
@@ -0,0 +1,63 @@
+from setuptools import setup, find_packages
+import glob
+
+# use softlinks to make the various "board-support-package" submodules
+# look like subpackages.  Then __init__.py will modify
+# sys.path so that the correct "local" versions of surf etc. are
+# picked up.  A better approach would be using relative imports
+# in the submodules, but that's more work.  -cpo
+setup(
+    name = 'cameralink_gateway',
+    description = 'LCLS II cameralink package',
+    packages = [
+        'cameralink_gateway.surf',
+        'cameralink_gateway.surf.misc',
+        'cameralink_gateway.surf.ethernet.mac',
+        'cameralink_gateway.surf.ethernet.xaui',
+        'cameralink_gateway.surf.ethernet.gige',
+        'cameralink_gateway.surf.ethernet.ten_gig',
+        'cameralink_gateway.surf.ethernet',
+        'cameralink_gateway.surf.ethernet.udp',
+        'cameralink_gateway.surf.protocols',
+        'cameralink_gateway.surf.protocols.pgp',
+        'cameralink_gateway.surf.protocols.ssp',
+        'cameralink_gateway.surf.protocols.rssi',
+        'cameralink_gateway.surf.protocols.jesd204b',
+        'cameralink_gateway.surf.protocols.ssi',
+        'cameralink_gateway.surf.protocols.i2c',
+        'cameralink_gateway.surf.protocols.batcher',
+        'cameralink_gateway.surf.protocols.clink',
+        'cameralink_gateway.surf.xilinx',
+        'cameralink_gateway.surf.devices.microchip',
+        'cameralink_gateway.surf.devices.ti',
+        'cameralink_gateway.surf.devices',
+        'cameralink_gateway.surf.devices.transceivers',
+        'cameralink_gateway.surf.devices.analog_devices',
+        'cameralink_gateway.surf.devices.micron',
+        'cameralink_gateway.surf.devices.linear',
+        'cameralink_gateway.surf.devices.nxp',
+        'cameralink_gateway.surf.devices.cypress',
+        'cameralink_gateway.surf.devices.silabs',
+        'cameralink_gateway.surf.devices.intel',
+        'cameralink_gateway.surf.axi',
+        'cameralink_gateway.l2si_core',
+        'cameralink_gateway.LclsTimingCore',
+        'cameralink_gateway.axipcie',
+        'cameralink_gateway.lcls2_pgp_fw_lib',
+        'cameralink_gateway.lcls2_pgp_fw_lib.hardware',
+        'cameralink_gateway.lcls2_pgp_fw_lib.hardware.XilinxKcu1500',
+        'cameralink_gateway.lcls2_pgp_fw_lib.hardware.SlacPgpCardG4',
+        'cameralink_gateway.lcls2_pgp_fw_lib.hardware.shared',
+        'cameralink_gateway.ClinkFeb', 
+    ],
+    package_dir = {
+        'cameralink_gateway': 'cameralink_gateway',
+        'cameralink_gateway.surf': 'submodules/surf/python/surf',
+        'cameralink_gateway.axipcie': 'submodules/axi-pcie-core/python/axipcie',
+        'cameralink_gateway.LclsTimingCore': 'submodules/lcls-timing-core/python/LclsTimingCore',
+        'cameralink_gateway.lcls2_pgp_fw_lib': 'submodules/lcls2-pgp-fw-lib/python/lcls2_pgp_fw_lib',
+        'cameralink_gateway.ClinkFeb': 'submodules/clink-gateway-fw-lib/python/ClinkFeb',
+        'cameralink_gateway.l2si_core': 'submodules/l2si-core/python/l2si_core',
+    }
+)
+
